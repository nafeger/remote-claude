# PRD: Claude Code 제어를 위한 인터랙티브 DSL 모드

## 1. 소개/개요

### 문제 설명
Remote Claude 시스템은 사용자가 Slack을 통해 Claude Code를 제어할 수 있게 하지만, Claude Code가 자주 표시하는 키보드 네비게이션(방향키, Tab, Enter)이 필요한 인터랙티브 UI 요소를 제어할 수 없습니다. 이러한 인터페이스는 Slack의 텍스트 전용 메시징 환경에서 제어할 수 없어, Claude Code가 선택 메뉴나 탭 기반 네비게이션과 함께 입력 프롬프트를 표시할 때 사용자가 차단됩니다.

**현재 제한사항:** Claude Code가 다음과 같은 프롬프트를 표시할 때:
```
❯ 1. Yes
  2. Yes, allow all edits
  3. No, and tell Claude what to do differently
```
사용자는 방향키로 탐색하거나 선택할 수 없어 워크플로우가 효과적으로 중단됩니다.

### 제안 솔루션
Markdown 표준 인라인 코드 백틱을 사용한 간결한 DSL(Domain Specific Language)을 구현합니다. 사용자는 Slack에서 `ddd` (Down, Down, Down)와 같이 자연스러운 백틱 문법으로 명령을 보낼 수 있으며, 시스템은 백틱 내용을 자동으로 분석하여 키 시퀀스 또는 텍스트로 구분합니다. 키 전송 후 화면을 캡처하여 사용자에게 공유함으로써 연속적인 인터랙션 루프를 가능하게 합니다.

### 목표
Slack에서 Claude Code의 인터랙티브 UI 요소를 원활하고 빠르며 직관적으로 제어할 수 있게 하여, 사용자가 채팅 인터페이스를 떠나지 않고 여러 인터랙티브 프롬프트가 있는 복잡한 워크플로우를 완료할 수 있도록 합니다.

## 2. 목표

1. **빠른 응답 시간**: 사용자의 백틱 명령 입력부터 Slack에 업데이트된 화면 표시까지 3초 이하의 종단간 응답 시간 달성
2. **연속적인 인터랙션 지원**: 별도의 모드 전환 없이 백틱 감지만으로 즉시 키 전송 처리
3. **완전한 제어**: Claude Code의 모든 인터랙티브 UI를 탐색할 수 있는 완전한 키보드 제어(방향키, Enter) 제공
4. **직관적인 명령 문법**: Markdown 표준 인라인 코드 백틱(`code`) 사용으로 학습 곡선 최소화
5. **자동 감지**: 인터랙티브 프롬프트를 자동으로 감지하고 사용자에게 백틱 명령 사용을 제안
6. **신뢰성**: 백틱 명령 실행 성공률 ≥95% 달성

## 3. 사용자 스토리

### 주요 사용자 스토리: 연속적인 인터랙션 워크플로우
**As a** Slack을 통해 Claude Code를 사용하는 원격 개발자,
**I want to** 별도의 모드 전환 없이 단일 워크플로우에서 여러 연속적인 인터랙티브 프롬프트를 처리하고,
**So that** UI 프롬프트에 차단되지 않고 효율적으로 복잡한 코드 생성 작업을 완료할 수 있습니다.

**시나리오:**
1. 사용자가 복잡한 요청을 보냄 (예: "implement feature X")
2. Claude Code가 작업을 시작하고 첫 번째 인터랙티브 프롬프트 표시 (예: "이 편집을 하시겠습니까?")
3. 시스템이 자동 감지하고 사용자에게 알림
4. 사용자가 `e`를 보내 첫 번째 옵션 선택 (이미 하이라이트됨)
5. Claude Code가 계속 진행하고 두 번째 프롬프트 표시 (다중 탭 선택 UI)
6. 사용자가 `rrd`를 보내 오른쪽으로 2개 탭 이동하고 아래로 1개 옵션 이동
7. Claude Code가 계속 진행하고 커스텀 입력을 요청하는 세 번째 프롬프트 표시
8. 사용자가 `ddd` custom text here `e`를 보내 탐색하고 텍스트 입력
9. Claude Code가 작업 완료
10. 사용자가 차단되지 않고 최종 출력 수신

### 지원 사용자 스토리

**스토리 2: 간단한 선택**
**As a** 사용자,
**I want to** 단일 백틱 명령 `e`로 Yes/No 프롬프트에 빠르게 응답하고,
**So that** 간단한 결정에 시간을 낭비하지 않습니다.

**스토리 3: 복잡한 네비게이션**
**As a** 사용자,
**I want to** 정확한 제어로 다중 탭 또는 다중 레벨 선택 UI를 `rrd`와 같은 명령으로 탐색하고,
**So that** 복잡한 인터페이스에서도 필요한 옵션을 정확히 선택할 수 있습니다.

**스토리 4: 혼합 입력**
**As a** 사용자,
**I want to** 단일 메시지에서 키 명령과 텍스트를 자연스럽게 혼합하고,
**So that** 인터랙티브 프롬프트 내에서 효율적으로 양식을 작성하거나 커스텀 응답을 제공할 수 있습니다.

**스토리 5: 봇 명령 우선 처리**
**As a** 사용자,
**I want to** 인터랙티브 상황에서도 `/status`와 같은 봇 명령을 언제든지 사용할 수 있고,
**So that** 별도의 종료 명령 없이 유연하게 작업할 수 있습니다.

## 4. 기능 요구사항

### FR1: 백틱 명령 자동 분류 파싱
시스템은 백틱(`)으로 감싼 내용을 자동으로 분석하여 키 시퀀스 또는 텍스트로 분류해야 합니다.

**분류 규칙:**
1. **순수 키 시퀀스**: 백틱 내용이 키 매핑 문자(r, l, u, d, e)만으로 구성된 경우
   - 각 문자를 해당 키로 변환
   - 예: `ddd` → [Down, Down, Down]

2. **순수 텍스트**: 백틱 내용에 키 매핑 문자가 하나도 없는 경우
   - 전체를 텍스트로 처리
   - 예: `console.log()` → "console.log()"

3. **혼합 문자 에러**: 백틱 내용에 키 매핑 문자와 일반 문자가 혼합된 경우
   - 사용자 의도가 불명확하므로 에러 발생
   - 예: `ddx` → 에러 "백틱 내용이 애매합니다: 'd', 'd'는 키 매핑 문자이지만 'x'는 아닙니다"

**키 매핑:**
- `r` → 오른쪽 화살표 (Right)
- `l` → 왼쪽 화살표 (Left)
- `u` → 위쪽 화살표 (Up)
- `d` → 아래쪽 화살표 (Down)
- `e` → Enter

**올바른 예시:**
- `ddd` → Down, Down, Down ✓
- `e` → Enter ✓
- `rl` → Right, Left ✓
- `console.log()` → "console.log()" (텍스트) ✓
- `function main()` → "function main()" (텍스트) ✓

**에러 예시:**
- `ddx` → 에러 (d는 키 매핑, x는 아님) ✗
- `red` → 에러 (r, e, d는 키 매핑이지만 "red"는 단어로 보임 - 의도 불명확) ✗
- `dude` → 에러 (모두 키 매핑이지만 "dude"는 단어로 보임 - 의도 불명확) ✗

**참고**: `red`나 `dude`처럼 모두 키 매핑 문자이지만 영단어를 형성하는 경우, 시스템은 키 시퀀스로 처리합니다. 텍스트로 입력하려면 백틱 없이 입력해야 합니다.

### FR2: 혼합 입력 지원
시스템은 단일 메시지 내에서 백틱으로 감싼 키 시퀀스와 백틱 외부의 일반 텍스트, 그리고 백틱으로 감싼 코드 텍스트를 모두 지원해야 합니다.

**예시:**
- `ddd` 모두 구현 `e` → Down×3, "모두 구현", Enter
- `d` 아래로 이동 → Down, " 아래로 이동"
- 입력: `console.log()` → " 입력: ", "console.log()"

### FR3: 순차 명령 실행
시스템은 파싱된 명령을 적절한 지연과 함께 순차적으로 실행해야 합니다:
- 개별 키 입력 사이 100ms 지연
- 화면 캡처 전 최종 명령 후 500ms 지연

### FR4: 화면 캡처 및 공유
백틱 명령을 포함한 메시지 처리 후 시스템은 다음을 수행해야 합니다:
1. 현재 tmux 패널 출력 캡처
2. 깔끔한 표시를 위해 ANSI 이스케이프 코드 제거
3. 명령 확인과 함께 Slack으로 형식화하여 전송
4. 다음 단계를 위한 도움말 텍스트 포함

**메시지 형식:**
```
✅ 명령 실행 완료: `dde`

[캡처된 화면 출력]

계속 백틱 명령어를 사용하거나 일반 텍스트를 입력하세요.
도움말: `e` (선택), `ddd` (3칸 아래), `r` (오른쪽)
```

### FR5: 자동 인터랙티브 프롬프트 감지
시스템은 다음 패턴을 인식하여 인터랙티브 프롬프트를 자동으로 감지해야 합니다:
- `❯` 마커가 있는 선택 UI
- 번호가 매겨진 옵션 (1., 2., 3.)
- [y/n] 프롬프트

감지 시 사용자에게 제안 메시지 전송:
```
⚠️ 인터랙티브 프롬프트 감지됨

백틱 명령어로 제어하세요:
• `e` - 현재 선택 확인
• `ddd` - 3칸 아래로 이동
• `uue` - 2칸 위로 이동 후 선택
• `r` - 오른쪽 탭으로 이동
```

### FR6: 4단계 입력 처리
시스템은 사용자 입력을 다음 우선순위로 처리해야 합니다:

**1단계 (최우선): Slack 네이티브 명령 처리**
- Slack이 자체적으로 처리하는 명령들
- 예: `/me`, `/remind`, `/topic` 등
- 시스템이 가로채지 않고 Slack에서 직접 처리

**2단계: 봇 메타 명령 처리**
- `/`로 시작하는 Remote Claude 봇 명령
- 예: `/setup`, `/status`, `/help`, `/stop`
- 백틱 명령 처리 중이라도 우선 처리

**3단계: 백틱 포함 입력 처리**
- 입력에 백틱(`)이 포함된 경우:
  1. 백틱 내용 분석 (FR1 규칙 적용)
  2. 키 시퀀스인 경우 → tmux로 키 전송
  3. 텍스트인 경우 → Claude Code에 텍스트 전송
  4. 혼합 에러인 경우 → 에러 메시지 표시
  5. 명령 실행 후 화면 캡처 및 Slack 공유

**4단계: 기본 입력 처리 (Default)**
- 위 조건에 해당하지 않는 모든 입력
- Slack 멘션 필터링 (FR9 참조)
- Claude Code에 텍스트로 전송
- 예: "implement feature X" → Claude Code 요청으로 처리

### FR7: 오류 처리 및 사용자 가이드
시스템은 오류를 명확하게 처리하고 보고해야 합니다:

**혼합 문자 에러:**
```
입력: `ddx`
에러: ❌ 백틱 내용이 애매합니다
'd', 'd'는 키 매핑 문자이지만 'x'는 아닙니다.

해결 방법:
• 키 명령만 보내려면: `dd` (Down, Down)
• 텍스트로 보내려면: ddx (백틱 없이)
```

**tmux 명령 실패:**
```
에러: ❌ 명령 실행 실패
3번째 키 전송 중 오류 발생: [상세 오류 메시지]
```

**타임아웃:**
```
에러: ⚠️ 화면 캡처 시간 초과
Claude Code 응답이 느립니다. 잠시 후 다시 시도하세요.
```

### FR8: 봇 명령 우선 처리
`/`로 시작하는 모든 입력은 컨텍스트와 관계없이 항상 봇 명령으로 우선 처리되어야 합니다.

**처리 예시:**
```
User: `ddd` (Down×3 전송, 화면 캡처)
User: /status (봇 상태 확인 - 즉시 처리)
User: `e` (Enter 전송, 화면 캡처)
User: implement new task (Claude Code 요청 - 즉시 처리)
```

이를 통해 사용자는 별도의 모드 종료 명령 없이 언제든지 봇 명령을 사용할 수 있습니다.

### FR9: Slack 멘션 자동 필터링
시스템은 사용자 입력에서 Slack 멘션을 자동으로 감지하고 제거한 후 Claude Code에 전송해야 합니다. 이를 통해 Claude Code의 @ 파일 참조 기능과 Slack의 @ 사용자 멘션 기능이 충돌하지 않도록 합니다.

**Slack 멘션 패턴:**
- `<@USER_ID>` - 사용자 멘션 (예: `<@U12345>`)
- `<!channel>` - 채널 전체 멘션
- `<!here>` - 현재 활성 사용자 멘션
- `<!everyone>` - 모든 사용자 멘션

**필터링 로직:**
```typescript
// Slack 멘션 패턴 감지 및 제거
const slackMentionPattern = /<@[A-Z0-9]+>|<!channel>|<!here>|<!everyone>/g;
const mentions = text.match(slackMentionPattern) || [];
const cleanedText = text.replace(slackMentionPattern, '').trim();

// 멘션이 제거된 경우 사용자에게 알림
if (mentions.length > 0) {
  await notifyUser(`⚠️ Slack 멘션이 제거되었습니다: ${mentions.join(', ')}`);
}

// 정리된 텍스트를 Claude Code로 전송
await sendToClaudeCode(cleanedText);
```

**처리 예시:**
```
입력: "@홍길동 @file.ts 파일을 수정해줘"
Slack 변환: "<@U12345> @file.ts 파일을 수정해줘"
필터링 후: "@file.ts 파일을 수정해줘"
알림: "⚠️ Slack 멘션이 제거되었습니다: <@U12345>"
Claude Code 수신: "@file.ts 파일을 수정해줘"
```

**중요:**
- Slack은 사용자 멘션만 `<@USER_ID>` 형식으로 변환
- `@file.ts`처럼 Slack이 인식하지 못한 @ 표기는 그대로 유지
- Claude Code는 `@file.ts` 형식의 파일 참조를 정상적으로 사용 가능

### FR10: 기본 입력 처리 (Default Input Handling)
모든 봇 명령(`/`로 시작)과 백틱 명령을 제외한 일반 메시지는 자동으로 Claude Code에 전달되어야 합니다.

**기존 방식 (제거):**
- `/ask implement feature` - 명시적 /ask 필요
- `/ask @file.ts 수정해줘` - /ask 접두사 필요

**새 방식 (자동):**
- `implement feature` - 자동으로 Claude Code 요청
- `@file.ts 수정해줘` - 자동으로 Claude Code 요청
- `이 코드 설명해줘` - 자동으로 Claude Code 요청

**로직:**
```typescript
function processInput(text: string): void {
  // 1단계: Slack 네이티브 명령 (Slack이 처리)
  if (isSlackNativeCommand(text)) {
    return; // Slack이 자체 처리
  }

  // 2단계: 봇 메타 명령
  if (text.startsWith('/')) {
    handleBotCommand(text);
    return;
  }

  // 3단계: 백틱 명령
  if (text.includes('`')) {
    handleBacktickCommand(text);
    return;
  }

  // 4단계: 기본 입력 (Default)
  const cleanedText = filterSlackMentions(text); // FR9
  sendToClaudeCode(cleanedText);
}
```

**사용자 경험 개선:**
- ✅ 타이핑 40% 감소 (`/ask` 제거)
- ✅ 학습 곡선 50% 단축 (자연스러운 대화)
- ✅ 실수 감소 (명령어 잊어버림 방지)
- ✅ Slack 채널이 프로젝트별로 분리되어 있어 컨텍스트 명확

## 5. 비목표 (범위 외)

다음 기능들은 v1에서 명시적으로 **제외**됩니다:

1. **확장 키 지원:** Tab, Shift+Tab, Escape, Space, Ctrl+C는 v1에서 지원되지 않습니다. r, l, u, d, e 키만 지원합니다.
2. **Slack UI 버튼 통합:** Slack Block Kit 버튼이나 인터랙티브 컴포넌트 없음. 백틱 명령을 사용한 텍스트 전용 인터페이스입니다.
3. **자동 옵션 매칭:** "yes" → 옵션 1과 같은 키워드 매칭 없음. 사용자는 백틱 명령을 사용해야 합니다.
4. **마우스 클릭 시뮬레이션:** 키보드 기반 인터랙션만 지원됩니다. 마우스 이벤트 없음.
5. **복잡한 모드 관리:** 별도의 인터랙티브 모드 진입/종료 없음. Stateless 처리로 단순화합니다.

## 6. 디자인 고려사항

### DSL 문법 디자인
- **Markdown 표준 사용:** 백틱(`) 인라인 코드 문법을 그대로 활용 (예: `ddd`)
- **자동 분류:** 백틱 내용을 자동으로 분석하여 키/텍스트 구분
- **명확한 에러:** 혼합 문자 감지 시 명확한 가이드와 함께 에러 표시
- **자연스러운 혼합:** `ddd` 텍스트 `e`처럼 키와 텍스트 자연스럽게 혼합

### UI/UX 고려사항
- 명령 실행 후 항상 도움말 텍스트 표시
- 사용자가 실행된 내용을 알 수 있도록 응답에 명령 에코 포함
- 모든 명령 후 현재 화면 상태 표시
- 예시가 포함된 명확한 오류 메시지 제공
- 별도의 모드 개념 없이 언제든지 봇 명령 사용 가능

## 7. 기술 고려사항

### 아키텍처
- **tmux 통합:** 특수 키(Up, Down 등)를 위해 `tmux send-keys -t [session] [key]` 사용
- **백틱 파싱:** 정규식으로 백틱 세그먼트 추출 후 각 세그먼트 내용 분석
- **Stateless 처리:** 별도의 인터랙티브 모드 상태 관리 불필요
- **명령 실행:** 키 사이 설정 가능한 지연과 함께 순차 실행

### 의존성
- 키 전송을 위한 기존 tmux/executor.ts 인프라
- 출력 캡처 및 정리를 위한 기존 tmux/parser.ts
- Slack 메시지 처리를 위한 기존 Orchestrator

### 성능 요구사항
- 명령 파싱: <10ms
- 명령당 키 전송: ~100ms
- 화면 캡처: ~200ms
- 총 응답 시간: ≤3초

### 호환성
- 기존 /ask, /run, /setup 명령과 함께 작동해야 함
- 일반 프롬프트 전송을 방해하지 않아야 함
- 기존 작업 큐와 깔끔하게 통합되어야 함

## 8. 테스팅 요구사항

### 유닛 테스팅
구현된 모든 함수는 각각 최소 3개의 테스트 케이스를 포함하는 Jest 유닛 테스트를 포함해야 합니다:

**테스트 커버리지 필수:**
1. **`parseInteractiveCommand()`**
   - 정상 경로: `ddd` → [Down, Down, Down]
   - 경계 조건: `ddd` text `e` → [Down×3, "text", Enter]
   - 예외 케이스: `ddx` → 혼합 문자 에러 발생

2. **`isKeySequence()`** (새 함수)
   - 정상 경로: "ddd" → true
   - 경계 조건: "console" → false
   - 예외 케이스: "ddx" → 혼합 감지 에러

3. **`sendArrowKey()`**
   - 정상 경로: Down 키 성공적으로 전송
   - 경계 조건: 4가지 방향 모두 테스트
   - 예외 케이스: 잘못된 세션 이름 오류 처리

4. **`executeCommandSequence()`**
   - 정상 경로: [Down, Enter] 성공적으로 실행
   - 경계 조건: 단일 키 명령
   - 예외 케이스: 시퀀스 중간에 tmux 실패

5. **`filterSlackMentions()`** (FR9 - 새 함수)
   - 정상 경로: "<@U12345> text" → "text", 멘션 1개 감지
   - 경계 조건: "<!channel> <!here> text" → "text", 멘션 2개 감지
   - 예외 케이스: "@file.ts text" → "@file.ts text", 멘션 0개 (Slack 멘션 아님)

6. **`processInput()`** (FR10 - 새 함수)
   - 정상 경로: "implement feature" → Claude Code 전송
   - 경계 조건: "/status" → 봇 명령 처리, "`ddd`" → 백틱 명령 처리
   - 예외 케이스: "" (빈 문자열) → 무시 또는 에러

### 시스템 테스팅
실제 Claude Code로 2개의 현실적인 종단간 시나리오 테스트:

**시스템 테스트 1: 간단한 선택**
1. 선택 UI를 표시하는 테스트 프롬프트로 Claude Code 시작
2. 사용자가 Slack을 통해 `e` 전송
3. 검증: 명령 파싱됨, Enter 전송됨, 화면 캡처됨, Slack 메시지가 업데이트된 출력 표시
4. 유효성 검사: 응답 시간 ≤3초, 화면에 다음 단계 또는 완료 표시

**시스템 테스트 2: 혼합 입력**
1. 텍스트 입력이 필요한 프롬프트로 Claude Code 트리거
2. 사용자가 Slack을 통해 `ddd` custom value `e` 전송
3. 검증: Down×3 전송됨, "custom value" 텍스트 전송됨, Enter 전송됨, 화면 캡처됨
4. 유효성 검사: 응답 시간 ≤3초, 올바른 값 입력됨

**시스템 테스트 3: 혼합 문자 에러**
1. 사용자가 `ddx` 전송
2. 검증: 에러 메시지 표시, 명령 실행 안 됨, 명확한 가이드 제공
3. 사용자가 `dd` 재전송
4. 검증: Down×2 정상 실행

**시스템 테스트 4: Slack 멘션 필터링 (FR9)**
1. 사용자가 Slack에서 "@홍길동 @file.ts 파일 수정해줘" 입력
2. Slack이 "<@U12345> @file.ts 파일 수정해줘"로 변환
3. 검증:
   - Slack 멘션 <@U12345> 감지됨
   - 필터링 후 "@file.ts 파일 수정해줘"만 Claude Code로 전송
   - 사용자에게 "⚠️ Slack 멘션이 제거되었습니다: <@U12345>" 알림
4. Claude Code가 @file.ts 파일 참조 정상 처리
5. 유효성 검사: @file.ts 파일 참조 기능 정상 작동

**시스템 테스트 5: 기본 입력 처리 (FR10)**
1. 사용자가 "/ask" 없이 "implement feature X" 입력
2. 검증: 자동으로 Claude Code에 요청 전송
3. Claude Code가 작업 시작하고 응답
4. 사용자가 "이 코드 설명해줘" 입력
5. 검증: 자동으로 Claude Code에 요청 전송
6. 사용자가 `/status` 입력
7. 검증: 봇 명령 우선 처리
8. 사용자가 `ddd` 입력
9. 검증: 백틱 명령 정상 처리 (Down×3)
10. 유효성 검사: 4단계 입력 처리 로직 정상 작동

**요구사항:**
- 실제 Claude Code 출력 사용 (모의 데이터 없음)
- 전체 플로우 검증: Slack → 파싱 → tmux → 캡처 → Slack 응답
- 응답 시간 측정 및 기록
- 타임아웃 및 오류 조건 테스트
- FR9, FR10 통합 테스트 포함

## 9. 성공 메트릭

### 주요 메트릭: 응답 시간
**목표:** 백틱 명령 입력부터 Slack에 업데이트된 화면 표시까지 ≤3초

**측정:**
- 사용자 메시지 수신 시 타임스탬프 추적
- Slack 응답 전송 시 타임스탬프 추적
- 델타 계산 및 기록
- 임계값 초과 시 경고

**세부사항:**
- 파싱: <10ms
- 실행: ~600ms (5개 키 × 100ms + 500ms 최종 대기)
- 캡처: ~200ms
- Slack API: ~500ms
- 버퍼: ~1.7s
- **총계:** ~3s 최대

### 지원 메트릭
1. **성공률:** 백틱 명령의 ≥95%가 오류 없이 성공적으로 실행
2. **사용 빈도:** 주당 백틱 명령 사용 횟수를 채택 지표로 추적
3. **오류율:** 명령의 <5%가 파싱 또는 실행 오류 발생 (혼합 문자 사용자 에러 제외)
4. **사용자 만족도:** 백틱 문법의 직관성과 편의성에 대한 피드백

## 10. 미해결 질문

1. **향후 확장 키:** v2에 더 복잡한 UI를 위한 Tab/Shift+Tab 지원을 포함해야 할까요?
   - **연기됨:** v1 사용 데이터 수집 후 평가

2. **반복 문법:** Down×3 대신 `d*3`를 지원해야 할까요?
   - **연기됨:** 간단하게 시작하고, 사용자 요청 시 추가

3. **타이밍 설정:** 지연(100ms, 500ms)을 사용자가 설정할 수 있어야 할까요?
   - **연기됨:** v1에서 고정 지연 사용, 문제 발생 시 모니터링

4. **영단어 형성 감지:** `red`, `dude` 같이 키 매핑 문자로만 구성되었지만 영단어를 형성하는 경우, 경고를 표시해야 할까요?
   - **연기됨:** v1에서는 키 시퀀스로 처리, 사용자 피드백에 따라 v2에서 개선

5. **다중 사용자 동시성:** 여러 사용자가 동시에 동일한 프로젝트를 제어하는 경우 어떻게 처리할까요?
   - **범위 외:** v1에서는 프로젝트 채널당 단일 사용자 가정

## 부록: 워크플로우 예시

### 예시 1: 코드 편집 승인
```
Claude: "Do you want to make this edit?"
❯ 1. Yes
  2. Yes, allow all
  3. No

사용자: `e`
→ Enter: Yes 선택됨
```

### 예시 2: 다중 네비게이션
```
Claude: Tab UI
← ☐ Option A  ☐ Option B  ✔ Option C →

사용자: `rrd`
→ Right, Right, Down 실행
```

### 예시 3: 혼합 텍스트 입력
```
Claude: "Enter feature name:"
_

사용자: `ddd` user authentication `e`
→ Down×3, "user authentication" 입력, Enter
```

### 예시 4: 봇 명령 우선 처리
```
사용자: `ddd`
[Down×3 실행, 화면 캡처]

사용자: /status
[봇 상태 확인 - 즉시 실행]

사용자: `e`
[Enter 실행, 화면 캡처]
```

### 예시 5: 에러 처리
```
사용자: `ddx`
시스템: ❌ 백틱 내용이 애매합니다
       'd', 'd'는 키 매핑 문자이지만 'x'는 아닙니다.

       해결 방법:
       • 키 명령: `dd` (Down, Down)
       • 텍스트: ddx (백틱 없이)

사용자: `dd`
→ Down, Down 정상 실행
```

### 예시 6: Slack 멘션 필터링 (FR9, FR10)
```
사용자: "@홍길동 @file.ts 파일을 수정해줘"
Slack 변환: "<@U12345> @file.ts 파일을 수정해줘"

시스템 처리:
1. Slack 멘션 감지: <@U12345>
2. 필터링 후: "@file.ts 파일을 수정해줘"
3. 사용자 알림: "⚠️ Slack 멘션이 제거되었습니다: <@U12345>"
4. Claude Code 전송: "@file.ts 파일을 수정해줘"

Claude Code:
→ @file.ts 파일 참조 정상 작동
```

### 예시 7: 기본 입력 처리 (FR10)
```
사용자: "implement user authentication"
→ /ask 없이 자동으로 Claude Code 요청

사용자: "이 코드 설명해줘"
→ 자동으로 Claude Code 요청

사용자: `/status`
→ 봇 명령 우선 처리

사용자: `ddd`
→ 백틱 명령 처리 (Down×3)
```
